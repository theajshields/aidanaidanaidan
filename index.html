<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="theme-color" content="#bc2524">
<meta property="og:site_name" content="aidan.port0.org">
<meta name="twitter:card" content="summary_large_image">
<meta name='twitter:site' content='@aidan' />
<meta name='twitter:title' content='aidanaidanaidan' />
<meta name='twitter:description' content='listen to aidanaidanaidan_radio' />
<meta name='twitter:image' content='/aidan.webp' />
<meta name='twitter:image:alt' content='thumbnail' />
<link rel="icon" type="image/x-icon" href="/favicon.png">
<script src="https://cdn.jsdelivr.net/npm/@macrowave/player@latest"></script>

<style>
  :root {
    --header-bg: light-dark(#f0f0f0, #1f1f1f);
  }

  body {
    margin: 0;
    min-height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 20px;
    overflow-x: hidden;
    
    background-color: #000;
    background:
      linear-gradient(0deg, rgba(0,0,0,1), rgba(51,10,9,1)),
      url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='7.76' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
  }

  .zoom-wrapper {
    width: 100%;
    max-width: 600px;
    transform: scale(1);
    transform-origin: top center;
    transition: transform 0.3s ease-out;
    min-height: 1px;
  }

  @media screen and (min-width: 1024px) {
    .zoom-wrapper {
      transform: scale(1.3);
      margin-top: -30px; 
      margin-bottom: -30px; 
    }
  }

  .main-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    width: 100%; 
  }

  /* making sure the player takes up space, even if the web component acts weird */
  macrowave-player {
    display: block; 
    filter: contrast(100%) brightness(100%);
    max-width: 100%;
    width: 100%;
  }

  .app-badge-link {
    transition: opacity 0.3s, visibility 0.3s;
  }
  
  .app-badge {
    width: clamp(80px, 15vw, 150px);
    height: auto;
    cursor: pointer;
    transition: opacity 0.2s;
  }

  .app-badge:hover {
    opacity: 0.8;
  }
</style>

</head>
<body>

  <div class="zoom-wrapper"> 
    <div class="main-container">
      <macrowave-player
        station="aidan/aidanaidanaidan"
        theme="dark">
      </macrowave-player>

      <a id="appBadgeLink" class="app-badge-link" 
        href="https://apps.apple.com/app/apple-store/id6746954963?pt=123127751&ct=macrowave.co&mt=8" target="_blank">
        <img class="app-badge" src="https://macrowave.co/images/app-store-badge.svg" alt="Download on the App Store">
      </a>
    </div>
  </div>

<script>
  // --- config stuff ---
  const TARGET_GREEN_RGB = 'rgb(106, 223, 71)';
  const REPLACE_RED_RGB = 'rgb(188, 37, 36)';
  const REPLACE_RED_HEX = '#bc2524';

  // this css is super important! it gets injected inside the player's secret shadow dom
  const SHADOW_STYLE_OVERRIDE = `
    /* forcing all the green utility classes to be red, just in case */
    [class*="text-[#6adf47]"], .text-\[\#6adf47\], .text-green-500 { color: ${REPLACE_RED_HEX} !important; }
    
    /* swapping background greens too */
    [class*="bg-[#6adf47]"], .bg-\[\#6adf47\] { background-color: ${REPLACE_RED_HEX} !important; }
    
    /* and borders, because why not? */
    [class*="border-[#6adf47]"], .border-\[\#6adf47\] { border-color: ${REPLACE_RED_HEX} !important; }
    
    /* one last attempt to catch any lingering green buttons */
    button[style*="${TARGET_GREEN_RGB}"] { background-color: ${REPLACE_RED_HEX} !important; }
  `;

  async function applyMacrowaveOverrides() {
    console.log("--- starting the color-swap mission ---");

    // 1. waiting for the custom player element to actually load its definition
    await customElements.whenDefined('macrowave-player');
    
    const player = document.querySelector('macrowave-player');
    if (!player) {
        console.error("uh oh, macrowave player element wasn't found!");
        return;
    }

    // 2. grabbing the shadow dom (the player's hidden internal document) or just the player itself
    const root = player.shadowRoot || player; 
    console.log(player.shadowRoot ? "found the secret shadow root, let's go inside..." : "looks like a regular element, working here.");

    // 3. injecting the custom red css directly into the player's internals
    const styleTag = document.createElement('style');
    styleTag.textContent = SHADOW_STYLE_OVERRIDE;
    root.appendChild(styleTag);
    console.log("injected the red css stylesheet successfully!");

    // 4. robust function to swap inline colors that look 'greenish' or 'orange-ish' into our red
    const swapInlineStyles = (node) => {
      if (!node || node.nodeType !== 1) return; // skip text and comments

      const styleText = node.getAttribute('style');
      let newStyle = styleText || '';
      let replaced = false;

      // helper: decide if a color is greenish enough to replace
      const isGreenish = (r, g, b) => {
        return (g > r + 18) && (g > b + 18) && (g >= 80);
      };

      // helper: decide if a color is orange-ish (for sound bars)
      const isOrangeish = (r, g, b) => {
        // orange typically: red high, green moderate, blue low
        return (r > g + 30) && (g > b + 15) && (r >= 140);
      };

      // parse and replace rgb(...) occurrences
      const rgbRegex = /rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)/gi;
      newStyle = newStyle.replace(rgbRegex, (match, rs, gs, bs) => {
        const r = parseInt(rs, 10), g = parseInt(gs, 10), b = parseInt(bs, 10);
        if (isGreenish(r, g, b) || isOrangeish(r, g, b)) {
          replaced = true;
          return REPLACE_RED_RGB;
        }
        return match;
      });

      // parse and replace hex colors (#rrggbb or #rgb)
      const hexRegex = /#([0-9a-f]{3}|[0-9a-f]{6})/gi;
      newStyle = newStyle.replace(hexRegex, (match, hex) => {
        try {
          let r, g, b;
          if (hex.length === 3) {
            r = parseInt(hex[0] + hex[0], 16);
            g = parseInt(hex[1] + hex[1], 16);
            b = parseInt(hex[2] + hex[2], 16);
          } else {
            r = parseInt(hex.slice(0,2), 16);
            g = parseInt(hex.slice(2,4), 16);
            b = parseInt(hex.slice(4,6), 16);
          }
          if (isGreenish(r, g, b) || isOrangeish(r, g, b)) {
            replaced = true;
            return REPLACE_RED_HEX;
          }
        } catch (e) {
          // ignore parse issues
        }
        return match;
      });

      // If style attribute changed, write it back
      if (replaced && styleText) {
        node.setAttribute('style', newStyle);
        console.log(`hacked the inline style on <${node.tagName}>. replaced green/orange colors.`);
      }

      // Additionally check common SVG attributes like fill/stroke and generic color attributes
      ['fill', 'stroke', 'color', 'background', 'background-color'].forEach(attr => {
        try {
          const val = node.getAttribute && node.getAttribute(attr);
          if (!val) return;

          // check rgb(...) in attribute
          let m = rgbRegex.exec(val);
          rgbRegex.lastIndex = 0;
          if (m) {
            const r = parseInt(m[1], 10), g = parseInt(m[2], 10), b = parseInt(m[3], 10);
            if (isGreenish(r, g, b) || isOrangeish(r, g, b)) {
              node.setAttribute(attr, REPLACE_RED_RGB);
              console.log(`replaced ${attr} rgb on <${node.tagName}>`);
            }
            return;
          }

          // check hex in attribute
          const hexMatch = val.match(/^#([0-9a-f]{3}|[0-9a-f]{6})$/i);
          if (hexMatch) {
            let hex = hexMatch[1].toLowerCase();
            let rr, gg, bb;
            if (hex.length === 3) {
              rr = parseInt(hex[0] + hex[0], 16);
              gg = parseInt(hex[1] + hex[1], 16);
              bb = parseInt(hex[2] + hex[2], 16);
            } else {
              rr = parseInt(hex.slice(0,2), 16);
              gg = parseInt(hex.slice(2,4), 16);
              bb = parseInt(hex.slice(4,6), 16);
            }
            if (isGreenish(rr, gg, bb) || isOrangeish(rr, gg, bb)) {
              node.setAttribute(attr, REPLACE_RED_HEX);
              console.log(`replaced ${attr} hex on <${node.tagName}>`);
            }
          }
        } catch (e) {
          // ignore
        }
      });
    };

    // 5. setting up the mutation observer (the 'security camera')
    // this watches the player for elements being added or styles being changed dynamically
    const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            if (mutation.type === 'childList') {
                mutation.addedNodes.forEach(node => {
                    swapInlineStyles(node);
                    if (node.querySelectorAll) {
                        // gotta check all the new children too
                        node.querySelectorAll('*').forEach(swapInlineStyles);
                    }
                });
            } else if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
                // if the style attribute changes on an existing element, swap it back to red
                swapInlineStyles(mutation.target);
            }
        });
    });

    observer.observe(root, { childList: true, subtree: true, attributes: true, attributeFilter: ['style'] });
    
    // running an initial check on existing elements just in case
    root.querySelectorAll('*').forEach(swapInlineStyles);

    // 6. Marquee for bottom dark-gray text when it overflows
    // Helper: determine if a color string is a dark gray we care about
    function parseRgbString(s) {
      const m = String(s).match(/rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i);
      if (!m) return null;
      return [parseInt(m[1],10), parseInt(m[2],10), parseInt(m[3],10)];
    }

    function isDarkGrayColorString(s) {
      const rgb = parseRgbString(s);
      if (!rgb) return false;
      const [r,g,b] = rgb;
      // require near-equal components (it's gray), and fairly dark but not black
      const eq = Math.abs(r-g) <= 12 && Math.abs(r-b) <= 12 && Math.abs(g-b) <= 12;
      const dark = r >= 30 && r <= 110; // mid-dark range
      return eq && dark;
    }

    function isOverflowing(el) {
      try { return el.scrollWidth > (el.clientWidth || el.offsetWidth) + 1; } catch (e) { return false; }
    }

    // Create marquee structure inside a container element
    function createMarquee(container) {
      if (!container) return;
      if (container.querySelector('.cw-marquee')) return; // already has one

      const wrapper = document.createElement('div');
      wrapper.className = 'cw-marquee';
      wrapper.style.display = 'block';
      wrapper.style.width = '100%';
      wrapper.style.overflow = 'hidden';
      wrapper.style.position = 'relative';

      const track = document.createElement('div');
      track.className = 'cw-marquee-track';
      track.style.display = 'inline-block';
      track.style.whiteSpace = 'nowrap';
      track.style.position = 'relative';
      track.style.left = '0';
      track.style.willChange = 'transform';

      const item = document.createElement('span');
      item.className = 'cw-marquee-item';
      item.style.display = 'inline-block';
      item.style.whiteSpace = 'nowrap';
      item.innerHTML = container.innerHTML;

      const spacer = document.createElement('span');
      spacer.style.display = 'inline-block';
      spacer.style.width = '2rem';

      const clone = item.cloneNode(true);

      track.appendChild(item);
      track.appendChild(spacer);
      track.appendChild(clone);

      wrapper.appendChild(track);
      container.innerHTML = '';
      container.appendChild(wrapper);

      requestAnimationFrame(() => refreshMarquee(wrapper));
    }

    function refreshMarquee(wrapper) {
      const track = wrapper.querySelector('.cw-marquee-track');
      if (!track) return;
      const firstItem = track.querySelector('.cw-marquee-item');
      if (!firstItem) return;

      const contentWidth = Math.ceil(firstItem.getBoundingClientRect().width + 1);
      if (!contentWidth) return;

      const prevStyle = wrapper._cwStyleTag;
      if (prevStyle && prevStyle.parentNode) prevStyle.parentNode.removeChild(prevStyle);

      const animName = 'cwMarquee_' + Math.random().toString(36).slice(2,9);
      const pxPerSecond = 60;
      const durationSec = Math.max(5, contentWidth / pxPerSecond);

      const style = document.createElement('style');
      style.textContent = `@keyframes ${animName} { from { transform: translateX(0); } to { transform: translateX(-${contentWidth}px); } }`;
      wrapper._cwStyleTag = style;
      try { root.appendChild(style); } catch (e) { document.head.appendChild(style); }

      track.style.animation = `${animName} ${durationSec}s linear infinite`;
      track.style.transform = 'translateX(0)';
    }

    function ensureMarquees() {
      try {
        // find candidate elements that have dark-gray computed color
        const candidates = Array.from(root.querySelectorAll('*')).filter(el => {
          try {
            const cs = window.getComputedStyle(el);
            if (!cs) return false;
            const color = cs.color || cs.getPropertyValue('color');
            return isDarkGrayColorString(color) && isOverflowing(el);
          } catch (e) { return false; }
        });

        candidates.forEach(el => {
          createMarquee(el);
        });
      } catch (e) {
        console.warn('ensureMarquees error', e);
      }
    }

    // Observe changes and re-run marquee detection
    const marqueeObserver = new MutationObserver((mutations) => { ensureMarquees(); });
    try { marqueeObserver.observe(root, { childList: true, subtree: true, characterData: true }); } catch (e) { marqueeObserver.observe(document.body, { childList: true, subtree: true, characterData: true }); }
    // initial check (delayed slightly to let internals render)
    setTimeout(ensureMarquees, 600);
  }

  // --- checking the operating system ---
  function checkOS() {
    const badgeLink = document.getElementById('appBadgeLink');
    if (badgeLink) {
        const userAgent = navigator.userAgent.toLowerCase();
        // if it's not an apple device, hide the badge
        if (!/iphone|ipad|ipod|macintosh/.test(userAgent)) {
            badgeLink.style.display = 'none';
        }
    }
  }

  // let's get this party started
  document.addEventListener('DOMContentLoaded', () => {
    checkOS();
    applyMacrowaveOverrides();
  });

</script>

</body>
</html>
