<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="theme-color" content="#bc2524">
<meta property="og:site_name" content="aidan.port0.org">
<meta name="twitter:card" content="summary_large_image">
<meta name='twitter:site' content='@aidan' />
<meta name='twitter:title' content='aidanaidanaidan' />
<meta name='twitter:description' content='listen to aidanaidanaidan_radio' />
<meta name='twitter:image' content='/aidan.webp' />
<meta name='twitter:image:alt' content='thumbnail' />
<link rel="icon" type="image/x-icon" href="/favicon.png">
<script src="https://cdn.jsdelivr.net/npm/@macrowave/player@latest"></script>

<style>
  :root {
    --header-bg: light-dark(#f0f0f0, #1f1f1f);
  }

  body {
    margin: 0;
    min-height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 20px;
    overflow-x: hidden;
    
    background-color: #000;
    background:
      linear-gradient(0deg, rgba(0,0,0,1), rgba(51,10,9,1)),
      url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='7.76' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
  }

  .zoom-wrapper {
    width: 100%;
    max-width: 600px;
    transform: scale(1);
    transform-origin: top center;
    transition: transform 0.3s ease-out;
    min-height: 1px;
  }

  @media screen and (min-width: 1024px) {
    .zoom-wrapper {
      transform: scale(1.3);
      margin-top: -30px; 
      margin-bottom: -30px; 
    }
  }

  .main-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    width: 100%; 
  }

  /* making sure the player takes up space, even if the web component acts weird */
  macrowave-player {
    display: block; 
    filter: contrast(100%) brightness(100%);
    max-width: 100%;
    width: 100%;
  }

  .app-badge-link {
    transition: opacity 0.3s, visibility 0.3s;
  }
  
  .app-badge {
    width: clamp(80px, 15vw, 150px);
    height: auto;
    cursor: pointer;
    transition: opacity 0.2s;
  }

  .app-badge:hover {
    opacity: 0.8;
  }
</style>

</head>
<body>

  <div class="zoom-wrapper"> 
    <div class="main-container">
      <macrowave-player
        station="aidan/aidanaidanaidan"
        theme="dark">
      </macrowave-player>

      <a id="appBadgeLink" class="app-badge-link" 
        href="https://apps.apple.com/app/apple-store/id6746954963?pt=123127751&ct=macrowave.co&mt=8" target="_blank">
        <img class="app-badge" src="https://macrowave.co/images/app-store-badge.svg" alt="Download on the App Store">
      </a>
    </div>
  </div>

<script>
  // --- config stuff ---
  const TARGET_GREEN_RGB = 'rgb(106, 223, 71)';
  const REPLACE_RED_RGB = 'rgb(188, 37, 36)';
  const REPLACE_RED_HEX = '#bc2524';

  // this css is super important! it gets injected inside the player's secret shadow dom
  const SHADOW_STYLE_OVERRIDE = `
    /* forcing all the green utility classes to be red, just in case */
    [class*="text-[#6adf47]"], .text-\[\#6adf47\], .text-green-500 { color: ${REPLACE_RED_HEX} !important; }
    
    /* swapping background greens too */
    [class*="bg-[#6adf47]"], .bg-\[\#6adf47\] { background-color: ${REPLACE_RED_HEX} !important; }
    
    /* and borders, because why not? */
    [class*="border-[#6adf47]"], .border-\[\#6adf47\] { border-color: ${REPLACE_RED_HEX} !important; }
    
    /* one last attempt to catch any lingering green buttons */
    button[style*="${TARGET_GREEN_RGB}"] { background-color: ${REPLACE_RED_HEX} !important; }
  `;

  async function applyMacrowaveOverrides() {
    console.log("--- starting the color-swap mission ---");

    // 1. waiting for the custom player element to actually load its definition
    await customElements.whenDefined('macrowave-player');
    
    const player = document.querySelector('macrowave-player');
    if (!player) {
        console.error("uh oh, macrowave player element wasn't found!");
        return;
    }

    // 2. grabbing the shadow dom (the player's hidden internal document) or just the player itself
    const root = player.shadowRoot || player; 
    console.log(player.shadowRoot ? "found the secret shadow root, let's go inside..." : "looks like a regular element, working here.");

    // 3. injecting the custom red css directly into the player's internals
    const styleTag = document.createElement('style');
    styleTag.textContent = SHADOW_STYLE_OVERRIDE;
    root.appendChild(styleTag);
    console.log("injected the red css stylesheet successfully!");

    // 4. robust function to swap inline colors that look 'greenish' or 'orange-ish' into our red
    const swapInlineStyles = (node) => {
      if (!node || node.nodeType !== 1) return; // skip text and comments

      const styleText = node.getAttribute('style');
      let newStyle = styleText || '';
      let replaced = false;

      // helper: decide if a color is greenish enough to replace
      const isGreenish = (r, g, b) => {
        return (g > r + 18) && (g > b + 18) && (g >= 80);
      };

      // helper: decide if a color is orange-ish (for sound bars)
      const isOrangeish = (r, g, b) => {
        // orange typically: red high, green moderate, blue low
        return (r > g + 30) && (g > b + 15) && (r >= 140);
      };

      // parse and replace rgb(...) occurrences
      const rgbRegex = /rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)/gi;
      newStyle = newStyle.replace(rgbRegex, (match, rs, gs, bs) => {
        const r = parseInt(rs, 10), g = parseInt(gs, 10), b = parseInt(bs, 10);
        if (isGreenish(r, g, b) || isOrangeish(r, g, b)) {
          replaced = true;
          return REPLACE_RED_RGB;
        }
        return match;
      });

      // parse and replace hex colors (#rrggbb or #rgb)
      const hexRegex = /#([0-9a-f]{3}|[0-9a-f]{6})/gi;
      newStyle = newStyle.replace(hexRegex, (match, hex) => {
        try {
          let r, g, b;
          if (hex.length === 3) {
            r = parseInt(hex[0] + hex[0], 16);
            g = parseInt(hex[1] + hex[1], 16);
            b = parseInt(hex[2] + hex[2], 16);
          } else {
            r = parseInt(hex.slice(0,2), 16);
            g = parseInt(hex.slice(2,4), 16);
            b = parseInt(hex.slice(4,6), 16);
          }
          if (isGreenish(r, g, b) || isOrangeish(r, g, b)) {
            replaced = true;
            return REPLACE_RED_HEX;
          }
        } catch (e) {
          // ignore parse issues
        }
        return match;
      });

      // If style attribute changed, write it back
      if (replaced && styleText) {
        node.setAttribute('style', newStyle);
        console.log(`hacked the inline style on <${node.tagName}>. replaced green/orange colors.`);
      }

      // Additionally check common SVG attributes like fill/stroke and generic color attributes
      ['fill', 'stroke', 'color', 'background', 'background-color'].forEach(attr => {
        try {
          const val = node.getAttribute && node.getAttribute(attr);
          if (!val) return;

          // check rgb(...) in attribute
          let m = rgbRegex.exec(val);
          rgbRegex.lastIndex = 0;
          if (m) {
            const r = parseInt(m[1], 10), g = parseInt(m[2], 10), b = parseInt(m[3], 10);
            if (isGreenish(r, g, b) || isOrangeish(r, g, b)) {
              node.setAttribute(attr, REPLACE_RED_RGB);
              console.log(`replaced ${attr} rgb on <${node.tagName}>`);
            }
            return;
          }

          // check hex in attribute
          const hexMatch = val.match(/^#([0-9a-f]{3}|[0-9a-f]{6})$/i);
          if (hexMatch) {
            let hex = hexMatch[1].toLowerCase();
            let rr, gg, bb;
            if (hex.length === 3) {
              rr = parseInt(hex[0] + hex[0], 16);
              gg = parseInt(hex[1] + hex[1], 16);
              bb = parseInt(hex[2] + hex[2], 16);
            } else {
              rr = parseInt(hex.slice(0,2), 16);
              gg = parseInt(hex.slice(2,4), 16);
              bb = parseInt(hex.slice(4,6), 16);
            }
            if (isGreenish(rr, gg, bb) || isOrangeish(rr, gg, bb)) {
              node.setAttribute(attr, REPLACE_RED_HEX);
              console.log(`replaced ${attr} hex on <${node.tagName}>`);
            }
          }
        } catch (e) {
          // ignore
        }
      });
    };

    // 5. setting up the mutation observer (the 'security camera')
    // this watches the player for elements being added or styles being changed dynamically
    const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            if (mutation.type === 'childList') {
                mutation.addedNodes.forEach(node => {
                    swapInlineStyles(node);
                    if (node.querySelectorAll) {
                        // gotta check all the new children too
                        node.querySelectorAll('*').forEach(swapInlineStyles);
                    }
                });
            } else if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
                // if the style attribute changes on an existing element, swap it back to red
                swapInlineStyles(mutation.target);
            }
        });
    });

    observer.observe(root, { childList: true, subtree: true, attributes: true, attributeFilter: ['style'] });
    
    // running an initial check on existing elements just in case
    root.querySelectorAll('*').forEach(swapInlineStyles);
  }

  // --------------------------------------------------------------------------
  // NEW: Marquee Logic for the specific gray text div
  // --------------------------------------------------------------------------
  async function applyMarqueeLogic() {
    await customElements.whenDefined('macrowave-player');
    const player = document.querySelector('macrowave-player');
    if (!player) return;
    const root = player.shadowRoot || player;

    // The logic to identify the div, check overflow, and apply <marquee>
    const checkAndMarqueeDiv = (node) => {
      // We look for divs with the specific style signature provided
      if (node && node.tagName === 'DIV') {
        const style = node.getAttribute('style') || "";
        // Match specific parts of the style string to be sure
        if (style.includes('color: rgb(136, 136, 136)') && style.includes('text-overflow: ellipsis')) {
          
          // Check if we already applied a marquee to avoid nesting or loops
          if (node.querySelector('marquee')) return;

          // Check if content is actually cut off (overflowing)
          if (node.scrollWidth > node.clientWidth) {
            console.log("Found overflowing gray text div, converting to marquee...");
            
            // Capture the text content
            const originalText = node.innerText;
            
            // Clear and replace with <marquee>
            // We set the width to 100% to fill the parent
            node.innerHTML = `<marquee behavior="scroll" scrollamount="3" style="width: 100%; color: inherit; font-family: inherit; font-size: inherit;">${originalText}</marquee>`;
            
            // Important: We need to override the parent's 'text-overflow: ellipsis' 
            // so it doesn't try to cut off the marquee element itself.
            node.style.textOverflow = 'clip';
            node.style.whiteSpace = 'normal'; // Allow marquee to behave normally
          }
        }
      }
    };

    // 1. Initial Scan
    const initialDivs = root.querySelectorAll('div');
    initialDivs.forEach(checkAndMarqueeDiv);

    // 2. Watch for new elements (using MutationObserver)
    const marqueeObserver = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === 'childList') {
          mutation.addedNodes.forEach(node => {
            if (node.nodeType === 1) { // Element node
              checkAndMarqueeDiv(node);
              // Also check children of added node
              if (node.querySelectorAll) {
                node.querySelectorAll('div').forEach(checkAndMarqueeDiv);
              }
            }
          });
        }
      });
    });
    marqueeObserver.observe(root, { childList: true, subtree: true });

    // 3. Watch for screen size updates (Resize)
    // If the screen resizes, the text might start overflowing.
    window.addEventListener('resize', () => {
      // Re-scan all potential divs
      const divs = root.querySelectorAll('div');
      divs.forEach(checkAndMarqueeDiv);
    });
  }

  // --- checking the operating system ---
  function checkOS() {
    const badgeLink = document.getElementById('appBadgeLink');
    if (badgeLink) {
        const userAgent = navigator.userAgent.toLowerCase();
        // if it's not an apple device, hide the badge
        if (!/iphone|ipad|ipod|macintosh/.test(userAgent)) {
            badgeLink.style.display = 'none';
        }
    }
  }

  // let's get this party started
  document.addEventListener('DOMContentLoaded', () => {
    checkOS();
    applyMacrowaveOverrides(); // Original color logic
    applyMarqueeLogic();       // New marquee logic
  });

</script>

</body>
</html>
